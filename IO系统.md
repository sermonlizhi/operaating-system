## 一、I/O硬件

#### 1.1 I/O设备

在计算机的主板上，CPU以及各类设备之间的数据传输都是通过总线来完成

总线：一组线路和通过线路传输信息的一个协议

以CPU和内存为例，它们之间的数据传输，一条线路一次只能传输一个bit，如果想要一次传输多个bit，就需要多条线路，多条线路为一组，称为总线，这种多条线路同时传输的方式称为并行，单条线路传输的方式称为串行。

如果设备与设备之间都是并行传输，以为这需要太多的总线，计算机的体积也会复杂起来，同时碍于线路的密度太高，彼此之间的传输也会收到影响，而从传输效率上，假设并行每秒传输100次，每次可以传8bit，那么串行每秒可以传输1000次，每次传输1bit，虽然同一时刻的传输数量不同，但传输效率也不同，所以现在主要采用串行总线的方式。

`PCIE、SATA、USB都是采用的串行总线`

##### 1.1.1 外围设备

在老式的主板和CPU中，CPU并不是直接与外围设备相连，而是通过两个芯片组，称为北桥和南桥，比较重要的外围设备(内存、显卡等)与北桥连接在一起，南桥连接一些非主要的外围设备(磁盘、声卡、网卡等)，然后南桥再连接到北桥上，北桥再与CPU通过总线连接在一起

随着现在CPU的集成度，北桥已经被直接集成到了CPU里面，而只剩下了南桥，称为Platform Controller Hub，所有的慢速设备都是通过它与CPU连接

每种外围设备都有一个插槽，这个插槽称为端口：

PCIE、SATA、USB(Universal Serial Bus)、VGA、HDMI、DVI、Thrunder Blot

USB称为统一串行总线，所有慢速外围设备鼠标、键盘、打印机等都通过这类接口连接

##### 1.1.2 设备类型

- 块设备(block device)

  存取基本单位是一个block，如磁盘、磁带、DVD等

- 字符设备(character device)

  存取基本单位是一个字符，如显示器、键盘、鼠标

##### 1.1.3 计算机中的I/O系统

<img src="https://raw.githubusercontent.com/sermonlizhi/picture/main/image-20210912154114595.png" alt="image-20210912154114595" style="zoom:50%;" />

所有的外围设备都是通过PCI总线与CPU连接，但又不是直接与CPU相连，都是通过一个控制器或适配器与CPU相连

#### 1.2  控制器

##### 1.2.1 控制器的功能

控制器有大有小，一般把大的控制器称为适配器，比如网络适配器、图形适配器

控制器是一个电子元件的集合，这个电子元件可以操作一个端口、一条总线或者一个设备

- 一个串行端口的控制器是一个简单的设备控制器，它就是一个简单的芯片或者芯片的部分，用于控制串行端口上的简单电信号
- SCSI总线控制器就不再是一个简单的控制器，因为SCSI协议很复杂。它包含了一个微处理器、微代码以及一些私有的内存，为了处理复杂的SCSI协议消息。在高级的控制器一般都包含微处理器，可以分担CPU的一些任务。
- 有一些设备有它自己内建的控制器，可以在磁盘背面看到一组电子芯片，这个就是它内建的控制器，它负责硬盘协议的实现，包括SCSI和SATA(Serial Advanced Technology Attachment)，这个磁盘控制器还包含微代码和处理器，可以做很多任务，比如：坏道检查、预加载、缓冲和缓存

##### 1.2.2 对控制器发布命令

控制器有一个或多个用于数据和控制信号的寄存器。CPU通过读写这些寄存器来控制通信：

- 控制寄存器

  可以被主机发布命令或更改设备状态，存放控制命令

- 状态寄存器

  包含一些主机可读的位信息

- 数据寄存器：

  记录主机可读或写入的数据，数据寄存器又包括读寄存器和写寄存器

<img src="https://raw.githubusercontent.com/sermonlizhi/picture/main/image-20210912160558808.png" alt="image-20210912160558808" style="zoom:50%;" />

#### 1.3 I/O地址

I/O地址：控制寄存器地址

CPU要将控制指令写入到控制寄存器，首先需要知道控制寄存器的地址

##### 1.3.1 I/O独立编址

<img src="https://raw.githubusercontent.com/sermonlizhi/picture/main/image-20210912162558979.png" alt="image-20210912162558979" style="zoom:50%;" />

CPU与设备控制器通过数据总线和地址总线直接相连，使用独立的I/O指令，如IN、OUT，直接向设备控制器的寄存器读写数据

##### 1.3.2 内存映射编址

<img src="https://raw.githubusercontent.com/sermonlizhi/picture/main/image-20210912162845445.png" alt="image-20210912162845445" style="zoom:30%;" />

在内存中划分出一块空间，将I/O的端口地址映射进来，这样就可以使用直接访问内存指令对控制器寄存器进行读写，因为内存中的地址与设备控制器中寄存器的地址具有映射关系，那么CPU读写内存，就相当于是读写寄存器

`实际生产中,独立编址和内存映射编址是一起使用的,有的设备采用独立编址,有的采用内存映射编址`

## 二、I/O控制方式

#### 2.1 轮询

<img src="https://raw.githubusercontent.com/sermonlizhi/picture/main/image-20210912163632234.png" alt="image-20210912163632234" style="zoom:50%;" />

以打印机为例，操作步骤如下：

- 重复测试busy位，直至清零

  打印机的状态寄存器中，有两个bit位分别表示busy bit和ready bit，当CPU需要向打印机写数据时，测试打印机的busy位是否处于忙碌，如果处于忙碌，则CPU过一段时间(循环)再次测试，直到打印机空闲

- 设置控制寄存器为write操作，并将要写入的字节X存入数据寄存器

- 设置ready位，如果ready位为1，则设置bush位

- 执行write命令，将字节X写入设备(打印出来)

- 清除ready位和bush位

优点：实现简单

缺点：CPU忙式等待，CPU的速度要比设备控制器的速度快很多，导致CPU时间片被大量耗费

#### 2.2 中断

<img src="https://raw.githubusercontent.com/sermonlizhi/picture/main/image-20210912170559178.png" alt="image-20210912170559178" style="zoom:50%;" />

当CPU需要向控制器发布命令时，首先发出一个初始化I/O的信号，然后就去处理其他的任务了，I/O控制器收到初始化指令后，如果设备正在忙碌，则它就一直等待，直到设备空闲后，I/O控制器向CPU发出一个中断信号，CPU收到中断信号后启动中断处理器，中断处理器将控制数据发送到I/O控制器，然后中断程序就执行完了，接着CPU切换到原来的任务继续执行，如果要再次向I/O控制器发送指令，则需要重复上面的步骤

优点：相比轮询的方式，中断方式不需要CPU忙式等待

缺点：在数据从内存传输到I/O控制器的过程中，CPU一直处于等待状态

#### 2.3 DMA(直接内存访问)

DMA这种方式早期用在磁盘访问，磁盘的访问都是大数据存储，在数据传输的过程中，CPU如果一直等待将非常影响性能

<img src="https://raw.githubusercontent.com/sermonlizhi/picture/main/image-20210912171541700.png" alt="image-20210912171541700" style="zoom:50%;" />

上图展示了DMA的工作流程，当CPU发送完从磁盘读取C个字节数据到内存的命令后，就执行其他的任务，而磁盘控制器就直接与DMA控制器进行数据传输，当数据传输完成之后，中断通知CPU数据传输完成，整个传输过程，CPU都在处理其他任务而不必等待。

DMA控制区需要通过内存总线向内存写数据，而CPU也需要通过内存总线从内存读取数据，当它们冲突时，任何处理呢？

`当DMA使用内存总线时，CPU当前是被阻止访问内存的，这种现象称为DMA窃取了CPU的执行周期，虽然周期窃取降低了CPU的运算能力，但将数据传输交给了DMA控制器来做,这种方式提高了整个系统的性能`

## 三、内核I/O结构

内核I/O结构包括I/O硬件和I/O软件两部分，I/O软件的设计目标主要体现在以下两点：

- 高效率：通过一些手段提供I/O设备的访问效率
- 通用性：屏蔽硬件细节，让用户使用统一的接口方便地使用不同的硬件

**I/O内核结构图如下：**

<img src="https://raw.githubusercontent.com/sermonlizhi/picture/main/image-20210912173344070.png" alt="image-20210912173344070" style="zoom:30%;" />

在软件层面，最下面的为驱动层，不同的设备有不同的驱动，由各自的设备厂商实现

#### 3.1 设备驱动层

设备驱动层通过隐藏不同的设备控制器，将内核I/O子系统和硬件隔离开来，所有的驱动按照操作系统定义的规范来实现，实现向上提供统一的接口

#### 3.2 内核I/O子系统

- 内核I/O子系统建立在硬件和设备驱动的基础架构之上，主要提供调度(I/O请求排队)、缓冲(buffering)、缓存(caching)、假脱机(spooling)、设备预留以及错误处理等功能
- I/O子系统同样要负责保护它自己，防止恶意进程和恶意用户

**BUFFERING**

主要用于处理数据流的生产者和消费者速度不匹配的问题，通过buffer(缓冲池)来解决

**BUFFER和CACHE**

缓冲保留的是过程数据(从生产者到消费者)，而缓存是将数据副本放到一个访问速度更快的硬件设备，缓存会有数据不一致的问题，但缓冲是没有这个问题的

**SPOOLING**

假脱机就是一个缓冲区，将不能并行执行的任务全部存放到缓冲里面，然后串行执行，给人的感觉像是在并行执行

#### 3.3 I/O请求周期

<img src="https://raw.githubusercontent.com/sermonlizhi/picture/main/image-20210912180139299.png" alt="image-20210912180139299" style="zoom:50%;" />

如果没有命中缓冲的时候，CPU向驱动发送请求，同时将请求I/O的进程放入等待队列，当I/O完成之后，设备控制器向CPU发出中断处理信息，如果是正常完成了I/O请求，则CPU将原来的进程从等待队列放入就绪队列中；如果I/O处理过程中，出现了错误中断，I/O子系统将会处理错误