`进程和线程都是CPU的调度单元,所以进程同步和线程同步是一样的概念,文中不具体细分进程和线程`

## 一、进程同步

在[详解操作系统进程](https://github.com/sermonlizhi/operating-system/blob/master/%E8%AF%A6%E8%A7%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B.md)<!--(https://blog.csdn.net/sermonlizhi/article/details/118700984?spm=1001.2014.3001.5502)-->中，介绍过了并发进程，并发进程之间分为独立关系和交互关系，独立关系的进程分别在自己的变量集合上运行，互不影响；但交互关系的并发进程在执行过程中需要共享或交换数据，因此交互的并发进程之间存在着竞争和协作关系。

#### 1.1 竞争

以一个打印机程序为例，当一个进程需要打印文件时，将文件放入打印机程序的打印目录中，目录中有很多槽位，每个槽位放置一个文件，每个进程在需要打印文件前，需要先知道接下来的那个槽位是空的(槽位是桉按顺序的)，然后才能将文件放置该槽位。

假设现在有A和B两个进程都需要打印文件，A进程执行程序，获取打印机的空闲槽位为5，但是在向槽位5放置文件之前，A进程发生了一次时钟中断(CPU时间片用完)，此时B进程进入CPU开始执行，它也发现槽位5是空的，于是将b文件放入槽位5中，而后退出CPU；接着A进程之前已经知道了槽位5是空闲的，于是直接将a文件放置在了槽位5，B进程的b文件被覆盖掉，当打印机程序从槽位取出文件打印时，只能打印出a文件。

类似上面的这种情况，即两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精准时序，称为**竞争条件(Race Condition)**

#### 1.2 异步

Asynchronous means Random，随机事件，任何时刻都会发生，没有一定的规则和顺序

上面打印机的例子，如果A进程在槽位5放置完文件才退出CPU，那么B进程就把文件放入槽位6，这样打印机程序就可以把a文件和b文件都打出出来了，完全取决于随机时序。

`异步才会引发竞争条件`

#### 1.3 同步

Process Synchronization means a mechanism to the consistency of data shared in cooperative process

进程同步是一种维持交互进程之间共享数据一致性的机制

同步的工具：Mutex Lock(互斥锁)和Semaphore(信号量)

## 二、互斥锁

#### 2.1 临界区

在上面的进程同步中，说到了当两个进程同时操作共享数据时，如果不加以干涉就会出问题，换言之，我们需要共享数据的进程之间互斥，即以一种手段确保当一个进程在使用共享数据时，其他进程不能做同样的操作。

每个进程中，对共享数据进行访问的程序片段被称为“临界区”。

**临界区定义**

- Each concurrent process has a segment of code,called a critical section ,in which the process may be changing common variables,updating a table,writing a file,and so on.

  每个并发进程中，修改公共数据、更新表、写文件(像这样的操作)的代码段称为重要区域(临界区)

- The important feature of the system is that,when one process is executing in its critical section,no other process is allowed to execute in its critial section.That is,NO two processes are executing in their cirtical sections at the same time.

  操作系统的重要特性是，当一个进程正在它的临界区执行时，没有其他进程被允许在临界区执行。换句话说，没有两个进程同时在临界区执行

- The critical-section problem is to design a protocol that the processes can use to cooperate.

  临界区问题就是设计一个进程可以协作的协议

临界区可以避免竞争，但不能保证共享数据的并发进程能够高效正确地协作，对于一个好的临界区协议，需要满足以下条件：

- 任何两个进程不能同时处于其临界区中
- 不应对CPU的速度和数量做任何假设(外部条件无关)
- 临界区运行的进程不能阻塞其他进程
- 不得使进程无限期等待进入临界区(有限等待)

`进程在进入临界区前,首先需要获得许可,使用完临界区退出时,要归还许可,其他进程才能进入临界区`

临界区协议的实现有软件和硬件两类方案，其中软件方案比较出名的是Dekker算法和Peterson算法，而硬件方案主要是Mutex Lock

#### 2.2 互斥锁(Mutex Lock)

##### Mutex Lock定义

- Operating-systems designers build software tools to solve the critical-section problem.The simplets of these tools is mutex lock

  操作系统设计人员建立软件工具来解决临界区问题，最简单的工具就是互斥锁

  - A procss must acquire the lock before entering a critical section

    一个进程进入临界区之前必须获取锁

  - It must release the lock when it exits the critical section

    进程在退出临界区时必须释放锁

为什么说互斥锁是硬件的实现方案呢，因为互斥锁需要通过执行TSL指令来获取锁，而TSL指令称为测试并加锁(test and set lock)，但它是一个原子操作，由硬件保证原子性，执行TSL指令时，执行该指令的CPU通过硬件锁住内存总线，其他CPU将无法访问内存，直到TSL指令执行完测试并加锁。

##### Lock原理

为了使用TSL指令，要使用一个共享变量lock来协调对共享内存的访问，当lock为0时，任何进程都可以使用TSL指令将其设置为1，并读写共享内存。当操作结束时，进程用一条普通的move指令将lock的值重新设置为0

```c
enter_regional:
	//复制锁到寄存器并将锁设为1,为什么直接设置为1呢？
	//只有TSL指令是原子操作,如果原来就是1,再设置成1没什么问题;如果原来是0,设置成1,防止TSL指令执行	   //完之后,其他进程来更改LOCK的值,能保证当前进程正确进入临界区
	TSL REGISTER,LOCK   
    //判断锁是否为0
    CMP REGISTER,#0
    //若不是0,说明锁已经被设置,所以循环等待
    JNE enter_regional
    RET
   
leave_regional:
	MOVE LOCK,#0    //在锁中存入0,表示该锁空闲
    RET				//返回调用者
```

通过上面的指令我们可以看出来，当一个进程想要获得lock锁，而lock又被其他进程占用时，就只能空循环等待

##### 忙式等待

- 忙式等待是指占用CPU执行空循环实现等待

- 这种类型的互斥锁也被称为“自旋锁”(spin lock)

  缺点：浪费CPU周期，可以将进程插入等待队列以让出CPU的使用权

  优点：进程在等待时没有上下文切换，对于使用锁时间不长的进程，自旋锁还是可以接收的；在多处理器系统中，自旋锁的优势更加明显

